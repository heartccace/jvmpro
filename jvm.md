### 1、类的加载过程

- 加载：将class文件加载到内存
- 链接
  1. 验证
  2. 准备：对静态变量赋予初始值
  3. 解析：将类、接口、方法的间接引用转换为直接引用
- 初始化
  1. 初始化阶段执行类构造方法<clinit>，此方法不需要定义，是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并而来
  2. 构造方法中指令按照语句在源文件中出现的顺序执行
  3. <clinit>不同于类的构造器
  4. 若该类具有父类，JVM会保证子类的<client>执行之前，父类的已经执行完毕
  5. 虚拟机必须保证一个类的<client>方法在多线程下被同步加锁

### 2、jvm内存结构

#### 1、pc寄存器

每个线程都有一个单独的程序寄存器

记录当前线程的下一条指令执行的位置，保证在CPU切换之后能继续执行

#### 2、虚拟机栈

栈帧：代表一个方法

当栈的大小被确定是：当超出设置的大小会抛出StackOverflowError

当栈的大小可以动态扩展时：申请不到内存时会抛出OutofMemeryError

-Xss可以设置栈大小（具体参考以下路径）

https://docs.oracle.com/en/java/javase/13/docs/specs/man/index.html，https://docs.oracle.com/en/java/javase/13/docs/specs/man/java.html

##### 栈帧的结构：

1、局部变量表

- 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量
- 由于局部变量表存在于线程栈上，线程时私有数据，因此不存在线程安全问题
- 局部变量表所需的容量大小是编译期确定下来的

2、操作数栈

- 主要用于保存计算过程中间结果，同时作为计算结果中间变量临时存储空间

3、动态连接（指向运行时常量池的方法引用）、

- ​	每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前代码能够实现动态链接
- 动态链接的作用是：将这些符号引用转换成调用方法的直接引用

4、方法返回地址

5、一些附加信息





静态绑定与动态绑定

静态链接：

​	当一个字节码文件被加载到JVM时，如果调用的目标方法在编译期可知，且运行期保持不变，这种情况下调用方法的符号引用转化为直接引用的过程称为静态链接



动态链接：

​	如果被调用的方法在编译期无法被确认下来，也就是说在运行期将方法的符号引用转换为直接引用才能确定下来，这个过程是动态的，称为动态链接。

#### 方法调用：虚方法（运行期才能确定）与非虚方法（在编译期可以确定）

- ##### invokestatic 调用静态方法，解析阶段确定为一方法版本

- ##### invokespecial 调用<init>方法、私有方法及父类方法，解析阶段确定为一方法版本

- ##### invokevirtual 调用所有虚方法

- ##### invokeinterface 调用接口方法

- ##### 动态调用指令：invokedynamic动态解析出需要调用的方法，然后执行

### 堆

jdk7分为：新生代、老年代、永久代（方法区）

jdk8+：新生代、老年代、元空间（方法区）



#### 堆空间内存大小设置：

-Xms和-Xmx两个参数设置一样，目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区大小，从而提高性能。



默认情况下，初始内存大小：物理电脑内存大小/64

最大内存大小：物理内存大小/4



堆分为：年轻代和老年代

年轻代分为：eden区 survivor0和survivor1区

其中 年轻代和老年代的参数设置

-XX: NewRatio=2表示新生代占1，老年代占2，新生代占整个堆的1/3

eden区和survivor0和survivor1区的比例是8：1：1 

-XX：SurvivorRatio=8

-XX：+UseAdaptiveSizePolicy 开启自适应内存分配彻略 

-Xmn设置新生代大小（优先级高）



当Eden区满的时候会触发younggc/minorgc导致eden区和survivor区被回收

-XX：MaxTenuringThreshold=15 默认垃圾回收15次未被回收就被晋升



当survivor满的时候，对象可以直接进入到老年区