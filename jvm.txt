栈上分配可以优化运行速度
栈上分配：
逃逸分析默认开启
可以通过：-XX：+DoEscapeAnalysis
可以通过：-XX: +PrintEscapeAnalysis查看逃逸分析的筛选结果

JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配，分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收
这样就无需进行垃圾回收。


同步策略：
在动态编译同步块的时候，JIT编译器可以借助挑一分析来判断同步块所使用的锁对象是否只能被一个线程访问，而没有被发布到其他线程。若果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样可以大大提高并发性和性能
这个取消同步的过程就叫同步省略，也叫锁消除。

分离对象或标量替换
标量（Scalar）指一个无法再分解成更小的数据的数据，java中的原始数据就是标量
相对的，那些还可以分解的数据叫做聚合量（Aggregate）
-XX：+EliminateAllocations 开启标量替换，默认打开，将对象打散分配在栈上



元空间不在虚拟机设置的内存中，而是使用本地内存

32位操作系统中-XX: PermSize 为64M
64位操作系统中-XX: PermSize 为 82M

JDK8
-XX：MetaspaceSize默认21M
-XX：MaxMetaspaceSize为-1（可自动调整）


方法区：
包含已被加载的类型信息（类、接口、枚举、方法等）、常量、静态变量、即时编译器编译之后的代码缓存等
声明为static final的变量在编译阶段就被赋值

字节码内部的常量池：
用于存放编译期间生成的各种字面量和符号引用，这部分内容将在类被加载后存放到方法区

方法区的常量池：
类所对应的常量池加载到内存形成方法区常量池，每个类都在内存中对应一个常量池，常量池中的符号引用全部转换为地址

元空间存在于本地内存，堆存在于虚拟机的虚拟内存。

永久代为什么被元空间代替？
1、永久代设置空间大小很难确定
2、永久代进行调优很困难

为什么将Stringtable放到堆？
因为永久代的回收效率很低，在full GC的时候才会触发，而fullGC是老年代空间不足或永久代空间不足才会触发。这就导致stringtable的
回收效率不高，而在程序运行时会创建大量的字符串，回收效率低，导致永久代内存不足。放到堆里，就能及时回收。




创建对象的步骤：
1.判断对象是否加载、链接、初始化
2.为对象分配内存
	如果内存规整，采用指针碰撞
	如果内存不规整，虚拟机维护一个列表，空间列表分配
3、处理并发安全：采用CAS配上失败重试保证更新的原子性，为每个线程分配一个TLAB
4、初始化分配的空间-所有属性默认值，保证对象不赋值时可以使用
5.设置对象的对象头
6.执行对象的init方法
