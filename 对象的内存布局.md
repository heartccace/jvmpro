### 对象的内存布局

- 对象头（header）

  1. 运行时元数据（mark word）
     - 哈希值
     - GC分代年龄
     - 锁状态标志
     - 线程持有的锁
     - 偏向线程ID
     - 偏向时间戳
  2. 类型指针-指向类元数据instanceKlass，确定该对象所属类型
  3. 如果是数组，还需记录数组的长度

- 实例数据

  1. 它是对象真正存储的有效信息，包括程序代码中定义的各种类型字段（包括从父类继承）
  2. 相同宽度的字段总是被分配到一起
  3. 父类中定义的变量会出现在子类变量之前
  4. 如果CompactFields参数为true（默认为true），子类的窄变量可以插入到父类变量的空隙

- 对其填充

  不是必须的，也没特殊含义，仅仅起到占位符作用

#### 对象的定位

- 句柄池
  1. 缺点
     - 空间消费多
     - 访问次数多
  2. 优点
     - 堆空间对象发生移动，影响小
- 直接指针（hotspot）
  - 节省空间
  - 访问速度快

### 执行引擎

- 解释执行

  对字节码采取逐行解释的方式执行

- 编译执行

  将源码直接翻译成机器能执行的语言

  #### 热点代码探测：

  ##### 热点代码:一个被多次调用的方法，或者是一个方法内部循环多次的循环体，称为栈上替换OSR

  ##### 热点探测：Hotspot采用计数器的热点探测器

  ##### client默认1500次，server为10000次，超过会触发jit

  可以通过 -XX: CompileThreshold



##### String

String的String pool是一个固定大小的Hashtable默认尺寸长度是1009。如果放进String pool的String非常多，就会造成hash冲突严重，从而导致链表过长，而链表过长会导致调用String.intern性能大幅下降

1. 常量与常量的拼接结果在常量池中，原理是编译期优化

2. 常量池中不会存在相同内容的常量

3. 只要其中一个是变量，结果就在堆中。变量拼接的原理是StringBuilder

4. 如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回对象的地址。

5. 如果字符串相加，两个变量都被final修饰，相当于两个常量相加

6. 字符串变量相加实现是通过Stringbuilder的append方法，最后调用Stringbuilder的toString方法，该方法会new一个String对象出来

   

##### intern()的使用

new String("ab")会创建两个对象，”ab“字面量会创建在常量池，new会在堆创建一个对象

new String("a") + new String("b")会创建6个对象

1. Stringbuilder
2. 常量池中的a
3. new String("a")
4. 常量池中的b
5. new String("b")
6. Stringbuilder的toString会创建一个String对象

intern会将当前对象在堆中是否有存在的字符串，如果有，返回存在字符串的地址，如果没有，将当前对象的地址作为该字符串在常量池中的地址





### 锁

#### 轻量级锁

当调用被synchronized修饰的对象时，在方法栈帧中会建立一个lock record（锁记录）包含了两部分：1.锁记录的地址 + 00（轻量级锁）2.对象引用（存储当前对象的引用地址）

加锁成功（cas）：表示将锁记录地址+00部份与对象头的markword（hashcode age bise 01）进行交换

#### 重入锁

当调用方法进入锁之后又调用另一个方法，锁住的同一个对象时，成为重入锁，重入锁任然会创建锁记录，锁记录的锁地址处为null，对象引用指向同一个锁对象，此时方法栈帧中有两个锁记录。

#### 解锁：

当获取到锁记录里面的值为空的话，直接将锁计数减一，直到值不为空，将锁记录第一个参数和对象头内容进行交换，表示解锁完成

#### 重量级锁：

当一个线程获取到了轻量级锁，另一个线程试图获取该锁，导致锁升级，及锁膨胀。

为对象申请一个monitor锁（monitor锁包含了一个ower，waitset，entryset），让对象的对象头指向重量级锁地址+10.轻量级锁解锁失败会走重量级解锁流程。根据对象头中的monitor地址，找到monitor



